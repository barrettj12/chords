package gqlgen

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.39

import (
	"context"
	"fmt"

	"github.com/barrettj12/chords/gqlgen/types"
	"github.com/barrettj12/chords/src/data"
)

// Artist is the resolver for the artist field.
func (r *albumResolver) Artist(ctx context.Context, obj *types.Album) (*types.Artist, error) {
	panic(fmt.Errorf("not implemented: Artist - artist"))
}

// Songs is the resolver for the songs field.
func (r *albumResolver) Songs(ctx context.Context, obj *types.Album) ([]*types.Song, error) {
	panic(fmt.Errorf("not implemented: Songs - songs"))
}

// Albums is the resolver for the albums field.
func (r *artistResolver) Albums(ctx context.Context, obj *types.Artist) ([]*types.Album, error) {
	panic(fmt.Errorf("not implemented: Albums - albums"))
}

// RelatedArtists is the resolver for the relatedArtists field.
func (r *artistResolver) RelatedArtists(ctx context.Context, obj *types.Artist) ([]*types.Artist, error) {
	artistsData, err := r.DB.Artists(ctx, data.ArtistsFilters{
		RelatedTo: data.ArtistID(obj.ID),
	})
	if err != nil {
		return nil, err
	}
	return r.translateArtists(artistsData), nil
}

// Artists is the resolver for the artists field.
func (r *queryResolver) Artists(ctx context.Context) ([]*types.Artist, error) {
	artistsData, err := r.DB.Artists(ctx, data.ArtistsFilters{})
	if err != nil {
		return nil, err
	}
	return r.translateArtists(artistsData), nil
}

// Artist is the resolver for the artist field.
func (r *queryResolver) Artist(ctx context.Context, id string) (*types.Artist, error) {
	artistsData, err := r.DB.Artists(ctx, data.ArtistsFilters{
		ID: data.ArtistID(id),
	})
	if err != nil {
		return nil, err
	}

	if len(artistsData) == 0 {
		return nil, nil
	}
	return r.translateArtist(artistsData[0]), nil
}

// Albums is the resolver for the albums field.
func (r *queryResolver) Albums(ctx context.Context) ([]*types.Album, error) {
	albumsData, err := r.DB.Albums(ctx, data.AlbumsFilters{})
	if err != nil {
		return nil, err
	}
	return r.translateAlbums(albumsData), nil
}

// Album is the resolver for the album field.
func (r *queryResolver) Album(ctx context.Context, id string) (*types.Album, error) {
	albumsData, err := r.DB.Albums(ctx, data.AlbumsFilters{
		ID: data.AlbumID(id),
	})
	if err != nil {
		return nil, err
	}

	if len(albumsData) == 0 {
		return nil, nil
	}
	return r.translateAlbum(albumsData[0]), nil
}

// Songs is the resolver for the songs field.
func (r *queryResolver) Songs(ctx context.Context) ([]*types.Song, error) {
	songsData, err := r.DB.Songs(ctx, data.SongsFilters{})
	if err != nil {
		return nil, err
	}
	return r.translateSongs(songsData), nil
}

// Song is the resolver for the song field.
func (r *queryResolver) Song(ctx context.Context, id string) (*types.Song, error) {
	panic(fmt.Errorf("not implemented: Song - song"))
}

// Artist is the resolver for the artist field.
func (r *songResolver) Artist(ctx context.Context, obj *types.Song) (*types.Artist, error) {
	panic(fmt.Errorf("not implemented: Artist - artist"))
}

// Album is the resolver for the album field.
func (r *songResolver) Album(ctx context.Context, obj *types.Song) (*types.Album, error) {
	panic(fmt.Errorf("not implemented: Album - album"))
}

// Album returns AlbumResolver implementation.
func (r *Resolver) Album() AlbumResolver { return &albumResolver{r} }

// Artist returns ArtistResolver implementation.
func (r *Resolver) Artist() ArtistResolver { return &artistResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Song returns SongResolver implementation.
func (r *Resolver) Song() SongResolver { return &songResolver{r} }

type albumResolver struct{ *Resolver }
type artistResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type songResolver struct{ *Resolver }
